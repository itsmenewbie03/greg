package remote

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/justchokingaround/greg/pkg/types"
)

type Client struct {
	NameStr string
	BaseURL string
	Client  *http.Client
}

func New(name, baseURL string) *Client {
	return &Client{
		NameStr: name,
		BaseURL: strings.TrimRight(baseURL, "/"),
		Client:  &http.Client{},
	}
}

func (c *Client) Name() string {
	return c.NameStr
}

func (c *Client) Search(query string) (*types.SearchResults, error) {
	// Assuming the remote API follows /{query} pattern for search
	// But standard consumet is /{provider}/{query}
	// The BaseURL should include the provider path, e.g. http://host/anime/gogoanime

	searchURL := fmt.Sprintf("%s/%s", c.BaseURL, url.PathEscape(query))

	resp, err := c.Client.Get(searchURL)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch search results: %w", err)
	}
	defer func() { _ = resp.Body.Close() }()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("remote search returned status %d", resp.StatusCode)
	}

	var results types.SearchResults
	if err := json.NewDecoder(resp.Body).Decode(&results); err != nil {
		return nil, fmt.Errorf("failed to decode search results: %w", err)
	}

	return &results, nil
}

func (c *Client) GetInfo(id string) (interface{}, error) {
	// Consumet API: /{provider}/info/{id}
	infoURL := fmt.Sprintf("%s/info/%s", c.BaseURL, id)

	resp, err := c.Client.Get(infoURL)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch info: %w", err)
	}
	defer func() { _ = resp.Body.Close() }()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("remote info returned status %d", resp.StatusCode)
	}

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Try to determine type based on content or just try unmarshaling
	// We can try AnimeInfo first, then MovieInfo, then MangaInfo

	// Try AnimeInfo
	var animeInfo types.AnimeInfo
	if err := json.Unmarshal(body, &animeInfo); err == nil && animeInfo.Title != "" {
		// Check if it looks like anime (has TotalEpisodes or Type is TV/OVA/etc)
		// Or just return it if it parsed successfully.
		// However, MovieInfo and AnimeInfo are similar.
		// Let's check for specific fields.
		// AnimeInfo has "totalEpisodes"
		// MovieInfo has "duration" (not in our struct) or "rating"

		// A simple heuristic: if it has "chapters", it's manga.
		if strings.Contains(string(body), `"chapters"`) {
			var mangaInfo types.MangaInfo
			if err := json.Unmarshal(body, &mangaInfo); err == nil {
				return &mangaInfo, nil
			}
		}

		// If it has "episodes", it could be anime or movie/tv
		// If we can't distinguish easily, we might need context.
		// But for now, let's try to unmarshal into AnimeInfo.
		return &animeInfo, nil
	}

	// Try MovieInfo
	var movieInfo types.MovieInfo
	if err := json.Unmarshal(body, &movieInfo); err == nil && movieInfo.Title != "" {
		return &movieInfo, nil
	}

	return nil, fmt.Errorf("failed to decode info into known types")
}

func (c *Client) GetSources(episodeID string) (interface{}, error) {
	// Consumet API: /{provider}/watch/{episodeId}
	// Note: Some providers use /read for manga?
	// Let's assume /watch for now, or check if it's manga.

	// If we don't know if it's manga or anime, we might have issues.
	// But usually manga uses /read or similar?
	// Consumet documentation says:
	// Anime: /anime/{provider}/watch/{episodeId}
	// Movies: /movies/{provider}/watch/{episodeId}
	// Manga: /manga/{provider}/read/{chapterId}

	// We can try /watch first.
	watchURL := fmt.Sprintf("%s/watch/%s", c.BaseURL, episodeID)

	resp, err := c.Client.Get(watchURL)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch sources: %w", err)
	}
	defer func() { _ = resp.Body.Close() }()

	if resp.StatusCode == http.StatusNotFound {
		// Try /read for manga
		readURL := fmt.Sprintf("%s/read/%s", c.BaseURL, episodeID)
		resp, err = c.Client.Get(readURL)
		if err != nil {
			return nil, fmt.Errorf("failed to fetch manga pages: %w", err)
		}
		defer func() { _ = resp.Body.Close() }()

		if resp.StatusCode == http.StatusOK {
			// It's likely manga pages
			// Consumet returns array of objects directly or wrapped?
			// Usually array of objects for pages.
			// Our types.MangaPages wraps it.

			var pages []*types.MangaPage
			if err := json.NewDecoder(resp.Body).Decode(&pages); err == nil {
				return &types.MangaPages{Pages: pages}, nil
			}
		}
	}

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("remote sources returned status %d", resp.StatusCode)
	}

	var sources types.VideoSources
	if err := json.NewDecoder(resp.Body).Decode(&sources); err != nil {
		return nil, fmt.Errorf("failed to decode sources: %w", err)
	}

	return &sources, nil
}

func (c *Client) GetServers(episodeID string) ([]types.EpisodeServer, error) {
	// Consumet API usually doesn't have a separate servers endpoint exposed in the same way for all providers,
	// or it's included in the source response?
	// Actually, consumet-api often has /servers/{episodeId}?
	// Let's assume /{provider}/servers/{episodeId} exists if needed.
	// If not, we return empty.

	serverURL := fmt.Sprintf("%s/servers/%s", c.BaseURL, episodeID)

	resp, err := c.Client.Get(serverURL)
	if err != nil {
		// If failed, just return empty list, don't error out completely as it might not be supported
		return []types.EpisodeServer{}, nil
	}
	defer func() { _ = resp.Body.Close() }()

	if resp.StatusCode != http.StatusOK {
		return []types.EpisodeServer{}, nil
	}

	var servers []types.EpisodeServer
	if err := json.NewDecoder(resp.Body).Decode(&servers); err != nil {
		return []types.EpisodeServer{}, nil
	}

	return servers, nil
}
