package flixhq

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"regexp"
	"strconv"
	"strings"
	"sync"

	"github.com/PuerkitoBio/goquery"
	"github.com/justchokingaround/greg/pkg/extractors"
	"github.com/justchokingaround/greg/pkg/types"
)

type FlixHQ struct {
	BaseURL     string
	Client      *http.Client
	searchCache sync.Map
	infoCache   sync.Map
}

func New() *FlixHQ {
	return &FlixHQ{
		BaseURL: "https://flixhq.to",
		Client:  &http.Client{},
	}
}

func (f *FlixHQ) Name() string {
	return "flixhq"
}

// Search searches for movies/shows by query
func (f *FlixHQ) Search(query string) (*types.SearchResults, error) {
	if cached, ok := f.searchCache.Load(query); ok {
		return cached.(*types.SearchResults), nil
	}

	// Replace non-word characters with hyphens
	re := regexp.MustCompile(`[\W_]+`)
	cleanQuery := re.ReplaceAllString(query, "-")
	searchURL := fmt.Sprintf("%s/search/%s", f.BaseURL, cleanQuery)

	req, err := http.NewRequest("GET", searchURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Add headers to mimic browser
	req.Header.Set("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36")
	req.Header.Set("Accept", "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8")
	req.Header.Set("Referer", f.BaseURL)

	resp, err := f.Client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch search results: %w", err)
	}
	defer func() { _ = resp.Body.Close() }()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("search returned status code %d", resp.StatusCode)
	}

	doc, err := goquery.NewDocumentFromReader(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to parse HTML: %w", err)
	}

	results := &types.SearchResults{
		Results: []types.SearchResult{},
	}

	// Parse search results
	doc.Find(".film_list-wrap > div.flw-item").Each(func(i int, s *goquery.Selection) {
		// Extract title
		title := strings.TrimSpace(s.Find(".film-detail .film-name a").Text())
		if title == "" {
			return
		}

		// Extract URL and ID
		href, exists := s.Find(".film-poster a").Attr("href")
		if !exists || href == "" {
			return
		}

		// ID is the href without leading slash
		id := strings.TrimPrefix(href, "/")

		// Extract image
		image, _ := s.Find(".film-poster img").Attr("data-src")

		// Extract release date from info
		releaseDate := ""
		typeStr := ""

		s.Find(".film-detail .fd-infor .fdi-item").Each(func(j int, info *goquery.Selection) {
			text := strings.TrimSpace(info.Text())

			// Check if this is the type (Movie/TV Series)
			if strings.Contains(text, "Movie") {
				typeStr = "Movie"
			} else if strings.Contains(text, "TV") {
				typeStr = "TV Series"
			}

			// Try to parse as year
			if year, err := strconv.Atoi(text); err == nil && year > 1900 && year < 2100 {
				releaseDate = text
			}
		})

		results.Results = append(results.Results, types.SearchResult{
			ID:          id,
			Title:       title,
			Image:       image,
			URL:         f.BaseURL + href,
			ReleaseDate: releaseDate,
			Type:        typeStr,
		})
	})

	f.searchCache.Store(query, results)
	return results, nil
}

// GetInfo fetches detailed info for a movie/show
func (f *FlixHQ) GetInfo(id string) (interface{}, error) {
	if cached, ok := f.infoCache.Load(id); ok {
		return cached.(*types.MovieInfo), nil
	}

	// Construct info URL
	infoURL := f.BaseURL + "/" + id
	if strings.HasPrefix(id, "/") {
		infoURL = f.BaseURL + id
	}

	req, err := http.NewRequest("GET", infoURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	req.Header.Set("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36")
	req.Header.Set("Referer", f.BaseURL)

	resp, err := f.Client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch movie info: %w", err)
	}
	defer func() { _ = resp.Body.Close() }()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("info request returned status code %d", resp.StatusCode)
	}

	doc, err := goquery.NewDocumentFromReader(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to parse HTML: %w", err)
	}

	info := &types.MovieInfo{
		ID:       id,
		URL:      infoURL,
		Episodes: []types.Episode{},
		Genres:   []string{},
	}

	// Extract title
	info.Title = strings.TrimSpace(doc.Find(".heading-name a").First().Text())

	// Extract image
	if img, exists := doc.Find(".m_i-d-poster img").Attr("src"); exists {
		info.Image = img
	}

	// Extract description
	info.Description = strings.TrimSpace(doc.Find(".description").Text())

	// Extract type and release date from row-lines
	doc.Find(".row-line").Each(func(i int, s *goquery.Selection) {
		label := strings.TrimSpace(s.Find("strong").Text())

		switch {
		case strings.Contains(label, "Released"):
			info.ReleaseDate = strings.TrimSpace(s.Find("a").First().Text())
		case strings.Contains(label, "Genre"):
			s.Find("a").Each(func(j int, genre *goquery.Selection) {
				genreText := strings.TrimSpace(genre.Text())
				if genreText != "" {
					info.Genres = append(info.Genres, genreText)
				}
			})
		}
	})

	// Determine if it's a movie or TV series
	if strings.Contains(strings.ToLower(info.Title), "season") ||
		doc.Find("#episodes-content").Length() > 0 {
		info.Type = "TV Series"

		// For TV series, extract episodes
		episodes := f.extractEpisodes(doc, id)
		info.Episodes = episodes
	} else {
		info.Type = "Movie"

		// For movies, create a single episode entry
		if watchID, exists := doc.Find(".watch_block").Attr("data-id"); exists {
			info.Episodes = []types.Episode{
				{
					ID:     watchID,
					Number: 1,
					Title:  info.Title,
				},
			}
		}
	}

	f.infoCache.Store(id, info)
	return info, nil
}

// extractEpisodes extracts episode information from the page
func (f *FlixHQ) extractEpisodes(doc *goquery.Document, movieID string) []types.Episode {
	episodes := []types.Episode{}

	// Find all episode items
	doc.Find(".ss-list a.ssl-item.ep-item").Each(func(i int, s *goquery.Selection) {
		epNum := strings.TrimSpace(s.Find(".ssli-order").Text())
		epTitle := strings.TrimSpace(s.Find(".ssli-detail .ep-name").Text())
		epID, _ := s.Attr("data-id")

		// Parse episode number
		num := i + 1
		if parsedNum, err := strconv.Atoi(epNum); err == nil {
			num = parsedNum
		}

		episodes = append(episodes, types.Episode{
			ID:     epID,
			Number: num,
			Title:  epTitle,
		})
	})

	return episodes
}

// GetServers fetches available servers for an episode
func (f *FlixHQ) GetServers(episodeID string) ([]types.EpisodeServer, error) {
	// For movies, episodeID is actually the movie data-id
	// Try movie endpoint first: /ajax/movie/episodes/{id}
	movieServerURL := fmt.Sprintf("%s/ajax/movie/episodes/%s", f.BaseURL, episodeID)

	req, err := http.NewRequest("GET", movieServerURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	req.Header.Set("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36")
	req.Header.Set("Referer", f.BaseURL)
	req.Header.Set("X-Requested-With", "XMLHttpRequest")

	resp, err := f.Client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch servers: %w", err)
	}
	defer func() { _ = resp.Body.Close() }()

	// If movie endpoint works, use it
	if resp.StatusCode == http.StatusOK {
		body, err := io.ReadAll(resp.Body)
		if err != nil {
			return nil, fmt.Errorf("failed to read response: %w", err)
		}

		servers, err := f.parseServersFromMovieHTML(string(body))
		if err == nil && len(servers) > 0 {
			return servers, nil
		}
	}

	// Fall back to TV series endpoint: /ajax/v2/episode/servers/{id}
	tvServerURL := fmt.Sprintf("%s/ajax/v2/episode/servers/%s", f.BaseURL, episodeID)

	req2, err := http.NewRequest("GET", tvServerURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	req2.Header.Set("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36")
	req2.Header.Set("Referer", f.BaseURL)
	req2.Header.Set("X-Requested-With", "XMLHttpRequest")

	resp2, err := f.Client.Do(req2)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch servers: %w", err)
	}
	defer func() { _ = resp2.Body.Close() }()

	// Read response body
	body, err := io.ReadAll(resp2.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response: %w", err)
	}

	// Try to parse as JSON first (new API format)
	var jsonResponse map[string]interface{}
	if err := json.Unmarshal(body, &jsonResponse); err == nil {
		// Check if it has an 'html' field containing the server HTML
		if htmlContent, ok := jsonResponse["html"].(string); ok && htmlContent != "" {
			return f.parseServersFromHTML(htmlContent)
		}
	}

	// Fall back to parsing the body as HTML directly (old format)
	return f.parseServersFromHTML(string(body))
}

// parseServersFromMovieHTML parses server list from movie episodes HTML
func (f *FlixHQ) parseServersFromMovieHTML(htmlContent string) ([]types.EpisodeServer, error) {
	doc, err := goquery.NewDocumentFromReader(strings.NewReader(htmlContent))
	if err != nil {
		return nil, fmt.Errorf("failed to parse HTML: %w", err)
	}

	servers := []types.EpisodeServer{}

	// Parse movie server links (format: <a href="/watch-movie/..." title="Vidcloud">)
	doc.Find("a").Each(func(i int, s *goquery.Selection) {
		serverName, _ := s.Attr("title")
		href, exists := s.Attr("href")

		if exists && serverName != "" && href != "" {
			// Extract episode ID from href (e.g., /watch-movie/watch-inception-19764.1613445)
			// The ID after the dot is the server/episode ID
			re := regexp.MustCompile(`\.(\d+)$`)
			if matches := re.FindStringSubmatch(href); len(matches) > 1 {
				serverID := matches[1]
				servers = append(servers, types.EpisodeServer{
					Name: serverName,
					URL:  fmt.Sprintf("%s/ajax/episode/sources/%s", f.BaseURL, serverID),
				})
			}
		}
	})

	return servers, nil
}

// parseServersFromHTML parses server list from HTML content (for TV series)
func (f *FlixHQ) parseServersFromHTML(htmlContent string) ([]types.EpisodeServer, error) {
	doc, err := goquery.NewDocumentFromReader(strings.NewReader(htmlContent))
	if err != nil {
		return nil, fmt.Errorf("failed to parse HTML: %w", err)
	}

	servers := []types.EpisodeServer{}

	// Parse server list
	doc.Find(".nav-item a").Each(func(i int, s *goquery.Selection) {
		serverName := strings.TrimSpace(s.Text())
		serverID, exists := s.Attr("data-id")

		if exists && serverName != "" {
			servers = append(servers, types.EpisodeServer{
				Name: serverName,
				URL:  fmt.Sprintf("%s/ajax/episode/sources/%s", f.BaseURL, serverID),
			})
		}
	})

	return servers, nil
}

// GetSources fetches video sources for an episode
func (f *FlixHQ) GetSources(episodeID string) (interface{}, error) {
	// Get servers first
	servers, err := f.GetServers(episodeID)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch servers: %w", err)
	}

	if len(servers) == 0 {
		return &types.VideoSources{
			Sources:   []types.Source{},
			Subtitles: []types.Subtitle{},
		}, nil
	}

	// Try each server until we get valid sources
	var lastErr error
	for _, server := range servers {
		sources, err := f.extractSourcesFromServer(server)
		if err != nil {
			lastErr = err
			continue
		}

		if len(sources.Sources) > 0 {
			return sources, nil
		}
	}

	// If all servers failed, return the last error
	if lastErr != nil {
		return nil, fmt.Errorf("failed to extract sources from all servers: %w", lastErr)
	}

	return &types.VideoSources{
		Sources:   []types.Source{},
		Subtitles: []types.Subtitle{},
	}, nil
}

// extractSourcesFromServer extracts video sources from a specific server
func (f *FlixHQ) extractSourcesFromServer(server types.EpisodeServer) (*types.VideoSources, error) {
	// Make request to get the embed URL
	req, err := http.NewRequest("GET", server.URL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	req.Header.Set("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36")
	req.Header.Set("Referer", f.BaseURL)
	req.Header.Set("X-Requested-With", "XMLHttpRequest")

	resp, err := f.Client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch sources: %w", err)
	}
	defer func() { _ = resp.Body.Close() }()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("server returned status %d for URL: %s", resp.StatusCode, server.URL)
	}

	// Read response body
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response: %w", err)
	}

	// Try to parse as JSON to get the embed URL
	var jsonResponse map[string]interface{}
	embedURL := ""

	if err := json.Unmarshal(body, &jsonResponse); err == nil {
		// Look for embed URL in different possible fields
		if link, ok := jsonResponse["link"].(string); ok {
			embedURL = link
		} else if link, ok := jsonResponse["embed"].(string); ok {
			embedURL = link
		} else if link, ok := jsonResponse["url"].(string); ok {
			embedURL = link
		}

		// If no direct link found, check for status/result pattern
		if embedURL == "" {
			// Some responses have {"status": 200, "result": {"url": "..."}}
			if result, ok := jsonResponse["result"].(map[string]interface{}); ok {
				if link, ok := result["url"].(string); ok {
					embedURL = link
				} else if link, ok := result["link"].(string); ok {
					embedURL = link
				}
			}
		}
	}

	// If we have an embed URL, extract sources from it
	if embedURL != "" {
		extractor := extractors.GetExtractor(server.Name)
		extracted, err := extractor.Extract(embedURL)
		if err != nil {
			return nil, fmt.Errorf("failed to extract from embed URL %s: %w", embedURL, err)
		}

		return extracted, nil
	}

	// If no embed URL found, return error with more context
	return nil, fmt.Errorf("no embed URL found in response from %s", server.URL)
}
